# Day 2：黑盒测试

日期：2025年10月16日

今日目标：

- 区分静态测试与动态测试

- 理解动态黑盒测试及其典型方法

- 熟悉每种方法的适用阶段与优缺点

## 一、静态测试与动态测试

| 分类维度     | 静态测试                 | 动态测试                         |
| ------------ | ------------------------ | -------------------------------- |
| 是否执行程序 | 不执行代码               | 执行代码                         |
| 目的         | 发现代码/设计缺陷        | 验证功能与行为                   |
| 常见方法     | 代码审查、走查、静态分析 | 单元测试、系统测试、黑盒用例执行 |
| 适用阶段     | 开发阶段早期             | 实现完成后                       |

## 二、静态黑盒测试

> 静态黑盒测试是一种在软件开发之前，通过检查产品说明书、需求文档、设计文档等来识别和发现问题的方法。

- **方法**: 主要包括对**文档**进行正式评审和检查。

- **目的**: 在开发阶段早期发现错误，从而减少后续修改成本。

- **特点**:

  **成本低**: 在编写代码前发现问题比在代码运行后发现问题更容易修复。

  **效率高**: 在不运行代码的情况下就能进行测试。

  **范围局限**: 只能发现文档中的问题，无法发现由于代码逻辑错误引起的bug。

## 三、动态黑盒测试

> 不深入代码细节测试软件的方法称为动态黑盒测试，它是动态（dynamic）的，因为程序在运行；同时，它是黑盒子，因为测试时不知道程序如何工作。测试员输入数据、接受输出、检验结果。动态黑盒测试常被称为行为测试。

动态黑盒测试不必了解软件“盒子”内发生的事情，只需要知道输入A输出B或执行操作C得到结果D，因此，清楚了被测试软件的输入和输出后，接下来就要开始定义**测试用例**。

### 1.通过性测试和失效性测试

**通过性测试**
确认软件至少能做什么，而不会考验其能力。软件测试员并不需要想尽办法让软件崩溃，仅仅运用最简单、最直观的测试用例即可。

**失效性测试**
确认软件在普通情况下能正确运行之后，就可以采取各种手段搞垮软件来找出软件缺陷了，又称为错误强制测试。是纯粹为了破坏软件而设计和执行的测试用例。

### 2.等价类划分

> 每个测试用例都必须体现尽可能多的不同的输入情况，以最大限度地减少测试所需的全部用例的数量，应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类。

使用等价划分方法设计测试用例主要有两个步骤：（1）确定等价类；（2）生成测试用例。

#### 2.1 确定等价类

我们确定了两类等价类，**有效等价类**代表对程序的有效输入，而**无效等价类**代表的则是其他任何可能的输入条件（即不正确的输入值）。

举个例子：输入字段：年龄（范围0~120，整数）

| 类型    | 等价类描述   | 举例  | 预期结果     |
| ------- | ------------ | ----- | ------------ |
| 有效类  | 0<=年龄<=120 | 25    | 正常接受     |
| 无效类1 | 年龄<0       | -5    | 提示输入非法 |
| 无效类2 | 年龄>120     | 200   | 提示输入非法 |
| 无效类3 | 非整数输入   | "abc" | 提示输入非法 |

这样我们测试时就只需测试25，-5， 200， “abc"，如果等价类的代表值测试通过，那么等价类中的其他值通常也不会有问题。

#### 2.2 生成测试用例

1.为每个等价类设置一个不同的编号。

2.编写新的测试用例，尽可能多地覆盖那些未被涵盖的有效等价类，直到所有的有效等价类都被测试用例所覆盖。

3.编写新的用例，覆盖一个且仅一个尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例覆盖。

### 3.数据测试

对软件最简单的认识就是将其分为两部分：**数据**和**程序**。数据包括键盘输入、鼠标单击、磁盘文件、打印输出等。程序是指可执行的流程、转化、逻辑和运算。

对数据进行软件测试，就是在检查用户输入的信息、返回的结果以及中间计算结果是否正确。

根据一些关键的原则进行**等价类划分**，以合理减少测试用例，这些关键的原则是：**边界条件**、**次边界条件**、**空值**和**无效数据**。

#### 3.1 边界条件

边界条件就是输入数据或输出结果的**取值极限**，
例如输入的最小值、最大值、上限、下限、长度边界等。

**举例**：系统要求用户年龄在 18～60 岁之间：

下边界：18

上边界：60

这些点就是边界条件。

#### 3.2 次边界条件

有些边界在软件内部，最终用户几乎看不见，这样的边界条件称为**次边界条件**或者**内部边界条件**。测试这样的边界需要了解软件的工作方式。常见的例子有**2的幂**和**ASCII表**。

**举例**：ASCII表，如果测试的文本框只接受用户输入字符A~Z和a~z

边界值：A，Z，a，z

次边界值：@，[，'，{（A~Z，a~z这些字符前后的值）

#### 3.3 空值

输入为空、或者没有提供输入值。这些值在软件中通常进行不同的处理，所以不要把他们与合法情况和非法情况混在一起，而是要建立单独的等价划分。

**举例：**

登录界面用户名留空（空字符串 `""`）

表单中没填写邮箱地址

#### 3.4 无效数据

输入数据**不符合要求或格式错误**的情况。

**举例：**

- 年龄输入“abc”
- 邮箱输入“user@@mail”
- 数字输入中带符号或特殊字符

### 4.状态测试

状态测试是一种基于系统“状态变化”的黑盒测试方法，通过输入不同事件、观察系统状态转移是否符合预期来检测软件行为。

#### 4.1 测试软件的逻辑流程

- **建立状态转换图**
  绘制此类图的技术并不重要，只要项目小组中的其它成员可以看懂就可以了。状态转换图应包含：
  1.软件可能进入的每一种独立状态；
  2.从一种状态进入另一种状态所需的输入和条件；
  3.进入或者退出某种状态时的设置条件及输出结果。
- **减少要测试的状态及转换的数量**
  正如对数据进行等价划分一样，需要将大量的可能性减少到可以操作的测试用例集合。有以下5种方法：
  1.每种状态至少访问一次；
  2.测试看起来是最常见和最普通的状态转换；
  3.测试状态之间最不常用的分支；
  4.测试所有错误状态及其返回值；
  5.测试随机状态转换（第15章 自动测试和测试工具）。
- **怎样进行具体测试**
  确定要测试的状态及其转换后，就可以定义测试用例了。测试状态及其转换包括检查所有的状态变量—与进入和退出状态相关的静态条件、信息、值、功能等。

#### 4.2 失败状态测试

以上的状态测试都属于**通过性测试**，包括审查软件、描绘状态、尝试各种合法可能性、确认状态及其转换正常。相反的做法就是找到使软件失败的案例。

- **竞争条件和时序错乱**
  多任务执行，多操作执行，多资源同时占用等。
- **重复、压迫和重负**
  重复测试：不断执行同样的操作，主要使检查内存泄露问题；
  压迫测试：使软件在不理想的条件下运行，例如内存小、磁盘空间少、CPU速度慢、网速低等。
  重负测试：与压迫测试相反，提供条件任其发挥，让软件处理尽可能大的数据文件。

## 四、学习心得

今天学习了黑盒测试的多种方法，最让我印象深刻的是“状态测试”。以前我认为测试只是验证输入输出，现在发现它其实是一种建模思维——软件就像一个有限状态机，每次操作都可能改变系统的“世界线”。这让我开始理解，真正的测试不是破坏，而是理解和揭示系统的行为边界。
